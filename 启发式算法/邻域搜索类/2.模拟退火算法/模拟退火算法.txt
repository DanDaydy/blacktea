https://mp.weixin.qq.com/s?__biz=MzU0NzgyMjgwNg==&mid=2247484661&idx=1&sn=b96e68355fda7b374291c6ef9a4eb6a9&chksm=fb49c94ccc3e405a040857f5e77d625d2e98574a772910419a8f3a84634201c8dfbd2a4eafce&scene=21#wechat_redirect

TSP问题（Traveling Salesman Problem，旅行商问题）


2.1.  什么是模拟退火算法(简介)   Simulated Annealing
模拟退火算法是一种通用概率演算法，用来在一个大的搜寻空间内找寻命题的最优解。它是基于Monte-Carlo迭代求解策略的一种随机寻优算法。
模拟退火算法是解决TSP问题的有效方法之一。

2.2
模拟退火: 其原理也和固体退火的原理近似。模拟退火算法从某一较高初温出发，伴随温度参数的不断下降,结合概率突跳特性在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。

2.3
爬山算法 (Hill Climbing Algorithm)
爬山算法是一种简单的贪心搜索算法，也可以被称为局部搜索算法（local search algorithm），该算法每次从当前解的临近解空间中选择一个最优解作为当前解，直到达到一个局部最优解。这种算法思想很单纯，但是也存在一个很大的缺陷。在搜索选择的过程中有可能会陷入局部最优解，而这个局部最优解不一定是全局最优解。

☆模拟退火算法在搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。

由初始解 i 和控制参数初值 t 开始，对当前解重复“产生新解→计算目标函数差→接受或丢弃”的迭代，并逐步衰减 t 值，算法终止时的当前解即为所得近似最优解。

1) 若f( Y(i+1) ) <= f( Y(i) ) (即移动后得到更优解)，则总是接受该移动。
2) 若f( Y(i+1) ) > f( Y(i) ) (即移动后的解比当前解要差)，则以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定）。

2.4 模拟退火算法伪代码
f(y): 状态y时的目标函数值
Y(i):当前状态
Y(i+1):新的状态
r:用于控制降温的快慢
T:系统的温度，系统初始应该处于一个高温状态
T_min:温度的下限，若温度T达到T_min，则停止搜索

while(T > T_min):
	dE = f(Y(i+1)) - f(Y(i))
	if dE >= 0 :
		Y(i+1) = Y(i)    #移动后得到更优解，则总是接受移动
	else:         #移动后没有变好，则要概率接受移动
		if exp(dE/T) > random(0,1):
			Y(i+1) = Y(i)
	T = r * T    #降温退火

==============================================
3.  使用模拟退火算法解决旅行商问题

TSP是经典的NP完全问题。精确的解决TSP的算法的时间复杂度是O(2^N), 其中N是节点的个数 。而使用模拟退火算法则可以快速地获得一条近似最优路径。

1)    产生一条新的遍历路径P(i+1)，计算路径P(i+1)的长度L( P(i+1) )。
2)    若L(P(i+1)) < L(P(i))，则接受P(i+1)为新的路径，否则以模拟退火的那个概率接受P(i+1) ，然后降温。
3)    重复步骤1，2直到满足退出条件。




模拟退火算法是一种随机算法，它有一定的概率能求得全局最优解，但不一定。用模拟退火算法可以较快速地找出问题的近似最优解。

===============================================

#这个看起来就愉快多了

1.计算两座城市之间的距离cal_distance
2.计算总路径长度path_len
3.模拟退火算法SA()
	3.1创造新路径creat_new  #随机交换两点
	#开始
	生成初始解，最后加上初始点0
	T>T_min：  #每个温度下迭代1000次
		创造新路径
		根据变化值执行算法
		迭代出了当前的满意解
	
4.main()


